# NetVis Pro 高可用架构设计

> 版本：v1.0
> 日期：2025-12-15

---

## 一、架构概述

### 设计目标

| 指标                 | 目标值   |
| -------------------- | -------- |
| 可用性 (SLA)         | 99.9%    |
| RTO (恢复时间目标)   | < 5 分钟 |
| RPO (数据恢复点目标) | < 1 分钟 |
| 故障切换时间         | < 30 秒  |

### 架构拓扑

```mermaid
graph TB
    subgraph "负载均衡层"
        VIP[虚拟IP - Keepalived]
        LB1[Nginx Primary]
        LB2[Nginx Standby]
    end

    subgraph "应用层"
        API1[API Server 1]
        API2[API Server 2]
        FE1[Frontend 1]
        FE2[Frontend 2]
    end

    subgraph "数据层"
        PG_M[(PostgreSQL Primary)]
        PG_S[(PostgreSQL Replica)]
        RS1[Redis Sentinel 1]
        RS2[Redis Sentinel 2]
        RS3[Redis Sentinel 3]
        RM[(Redis Master)]
        RR[(Redis Replica)]
    end

    VIP --> LB1
    VIP -.-> LB2
    LB1 --> API1
    LB1 --> API2
    LB1 --> FE1
    LB1 --> FE2
    API1 --> PG_M
    API2 --> PG_M
    PG_M --> PG_S
    RS1 --> RM
    RS2 --> RM
    RS3 --> RM
    RM --> RR
```

---

## 二、组件高可用配置

### 2.1 PostgreSQL 主从复制

#### 主库配置 (postgresql.conf)

```ini
# 复制设置
wal_level = replica
max_wal_senders = 3
wal_keep_size = 1GB
synchronous_commit = on
synchronous_standby_names = 'standby1'

# 归档设置
archive_mode = on
archive_command = 'cp %p /var/lib/postgresql/archive/%f'
```

#### 从库配置 (standby.signal)

```ini
# 创建standby.signal文件表示从库模式
primary_conninfo = 'host=pg-primary port=5432 user=replicator password=xxx'
recovery_target_timeline = 'latest'
```

### 2.2 Redis Sentinel 配置

#### sentinel.conf

```ini
# 监控主节点
sentinel monitor netvis-master redis-master 6379 2
sentinel auth-pass netvis-master your_redis_password

# 故障切换设置
sentinel down-after-milliseconds netvis-master 5000
sentinel failover-timeout netvis-master 60000
sentinel parallel-syncs netvis-master 1

# 通知脚本
sentinel notification-script netvis-master /scripts/notify.sh
sentinel client-reconfig-script netvis-master /scripts/reconfig.sh
```

### 2.3 Keepalived + Nginx 负载均衡

#### keepalived.conf (Primary)

```ini
vrrp_script chk_nginx {
    script "/usr/bin/pgrep nginx"
    interval 2
    weight 2
}

vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 101
    advert_int 1

    authentication {
        auth_type PASS
        auth_pass netvis_ha
    }

    virtual_ipaddress {
        192.168.1.100/24
    }

    track_script {
        chk_nginx
    }
}
```

#### nginx.conf (负载均衡)

```nginx
upstream api_servers {
    least_conn;
    server api1:21301 weight=5 max_fails=3 fail_timeout=30s;
    server api2:21301 weight=5 max_fails=3 fail_timeout=30s;
    keepalive 32;
}

upstream frontend_servers {
    ip_hash;
    server frontend1:80;
    server frontend2:80;
}

server {
    listen 80;
    server_name netvis.example.com;

    location /api {
        proxy_pass http://api_servers;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_connect_timeout 5s;
        proxy_read_timeout 60s;
    }

    location / {
        proxy_pass http://frontend_servers;
    }
}
```

---

## 三、Docker Compose 高可用配置

### docker-compose.ha.yml

```yaml
version: "3.8"

services:
  # PostgreSQL 主库
  postgres-primary:
    image: postgres:15-alpine
    container_name: netvis-pg-primary
    environment:
      POSTGRES_USER: netvis
      POSTGRES_PASSWORD: ${PG_PASSWORD}
      POSTGRES_DB: netvis
    volumes:
      - pg_primary_data:/var/lib/postgresql/data
      - ./config/postgres/primary.conf:/etc/postgresql/postgresql.conf
    command: postgres -c config_file=/etc/postgresql/postgresql.conf
    networks:
      - netvis-ha

  # PostgreSQL 从库
  postgres-replica:
    image: postgres:15-alpine
    container_name: netvis-pg-replica
    environment:
      PGUSER: replicator
      PGPASSWORD: ${REPL_PASSWORD}
    volumes:
      - pg_replica_data:/var/lib/postgresql/data
    depends_on:
      - postgres-primary
    networks:
      - netvis-ha

  # Redis 主节点
  redis-master:
    image: redis:7-alpine
    container_name: netvis-redis-master
    command: redis-server --requirepass ${REDIS_PASSWORD} --appendonly yes
    volumes:
      - redis_master_data:/data
    networks:
      - netvis-ha

  # Redis 从节点
  redis-replica:
    image: redis:7-alpine
    container_name: netvis-redis-replica
    command: redis-server --replicaof redis-master 6379 --masterauth ${REDIS_PASSWORD} --requirepass ${REDIS_PASSWORD}
    depends_on:
      - redis-master
    networks:
      - netvis-ha

  # Redis Sentinel 1
  redis-sentinel-1:
    image: redis:7-alpine
    container_name: netvis-sentinel-1
    command: redis-sentinel /etc/redis/sentinel.conf
    volumes:
      - ./config/redis/sentinel.conf:/etc/redis/sentinel.conf
    networks:
      - netvis-ha

  # Redis Sentinel 2
  redis-sentinel-2:
    image: redis:7-alpine
    container_name: netvis-sentinel-2
    command: redis-sentinel /etc/redis/sentinel.conf
    volumes:
      - ./config/redis/sentinel.conf:/etc/redis/sentinel.conf
    networks:
      - netvis-ha

  # Redis Sentinel 3
  redis-sentinel-3:
    image: redis:7-alpine
    container_name: netvis-sentinel-3
    command: redis-sentinel /etc/redis/sentinel.conf
    volumes:
      - ./config/redis/sentinel.conf:/etc/redis/sentinel.conf
    networks:
      - netvis-ha

  # API Server 1
  api-1:
    build: ./server
    container_name: netvis-api-1
    environment:
      - DATABASE_URL=postgresql://netvis:${PG_PASSWORD}@postgres-primary:5432/netvis
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis-master:6379
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - postgres-primary
      - redis-master
    networks:
      - netvis-ha

  # API Server 2
  api-2:
    build: ./server
    container_name: netvis-api-2
    environment:
      - DATABASE_URL=postgresql://netvis:${PG_PASSWORD}@postgres-primary:5432/netvis
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis-master:6379
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - postgres-primary
      - redis-master
    networks:
      - netvis-ha

  # Nginx 负载均衡
  nginx:
    image: nginx:alpine
    container_name: netvis-lb
    ports:
      - "21800:80"
      - "21443:443"
    volumes:
      - ./config/nginx/ha.conf:/etc/nginx/nginx.conf
    depends_on:
      - api-1
      - api-2
    networks:
      - netvis-ha

volumes:
  pg_primary_data:
  pg_replica_data:
  redis_master_data:

networks:
  netvis-ha:
    driver: bridge
```

---

## 四、故障切换流程

### 4.1 数据库故障切换

```mermaid
sequenceDiagram
    participant App as 应用
    participant PG_M as PostgreSQL主库
    participant PG_S as PostgreSQL从库
    participant Monitor as 监控脚本

    PG_M->>Monitor: 心跳检测失败
    Monitor->>Monitor: 等待超时(5s)
    Monitor->>PG_S: pg_ctl promote
    PG_S->>PG_S: 切换为主库
    Monitor->>App: 更新连接地址
    App->>PG_S: 重新连接
```

### 4.2 Redis 故障切换

```mermaid
sequenceDiagram
    participant App as 应用
    participant S1 as Sentinel 1
    participant S2 as Sentinel 2
    participant S3 as Sentinel 3
    participant RM as Redis Master
    participant RR as Redis Replica

    RM->>S1: 心跳失败
    RM->>S2: 心跳失败
    S1->>S2: 投票故障切换
    S2->>S3: 投票故障切换
    S1->>RR: SLAVEOF NO ONE
    RR->>RR: 提升为Master
    S1->>App: 通知新Master地址
```

---

## 五、监控与告警

### 健康检查脚本 (health-check-ha.sh)

```bash
#!/bin/bash

# PostgreSQL 复制状态检查
check_pg_replication() {
    LAG=$(psql -h pg-primary -U netvis -t -c "SELECT pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) FROM pg_stat_replication;")
    if [ "$LAG" -gt 1048576 ]; then
        echo "WARNING: PostgreSQL复制延迟过大: ${LAG} bytes"
        return 1
    fi
}

# Redis Sentinel 状态检查
check_redis_sentinel() {
    MASTER=$(redis-cli -h sentinel-1 -p 26379 SENTINEL get-master-addr-by-name netvis-master)
    if [ -z "$MASTER" ]; then
        echo "ERROR: Redis Sentinel无法获取Master地址"
        return 1
    fi
}

# 执行检查
check_pg_replication
check_redis_sentinel
```

---

## 六、部署步骤

1. **准备配置文件**

   ```bash
   mkdir -p config/{postgres,redis,nginx}
   cp docs/ha-configs/* config/
   ```

2. **启动高可用集群**

   ```bash
   docker compose -f docker-compose.ha.yml up -d
   ```

3. **验证复制状态**

   ```bash
   ./scripts/health-check-ha.sh
   ```

4. **配置 Keepalived** (需在物理机或 VM 上配置)
   ```bash
   sudo apt install keepalived
   sudo cp config/keepalived.conf /etc/keepalived/
   sudo systemctl enable keepalived
   ```
